<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>CUB: cub::WarpScan&lt; T, LOGICAL_WARPS, LOGICAL_WARP_THREADS &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-38890655-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CUB
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecub.html">cub</a></li><li class="navelem"><a class="el" href="classcub_1_1_warp_scan.html">WarpScan</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="classcub_1_1_warp_scan-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cub::WarpScan&lt; T, LOGICAL_WARPS, LOGICAL_WARP_THREADS &gt; Class Template Reference<div class="ingroups"><a class="el" href="group___warp_module.html">Warp-wide</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed description</h2>
<div class="textblock"><h3>template&lt;
    typename T, 
    int LOGICAL_WARPS = 1, 
    int LOGICAL_WARP_THREADS = PtxArchProps::WARP_THREADS&gt;<br/>
class cub::WarpScan&lt; T, LOGICAL_WARPS, LOGICAL_WARP_THREADS &gt;</h3>

<p><a class="el" href="classcub_1_1_warp_scan.html" title="WarpScan provides variants of parallel prefix scan across CUDA warps. . ">WarpScan</a> provides variants of parallel prefix scan across CUDA warps. </p>
<div class="image">
<img src="warp_scan_logo.png" alt="warp_scan_logo.png"/>
<div class="caption">
.</div></div>
 <dl class="section user"><dt>Overview</dt><dd>Given a list of input elements and a binary reduction operator, a <a href="http://en.wikipedia.org/wiki/Prefix_sum"><em>prefix scan</em></a> produces an output list where each element is computed to be the reduction of the elements occurring earlier in the input list. <em>Prefix sum</em> connotes a prefix scan with the addition operator. The term <em>inclusive</em> indicates that the <em>i</em><sup>th</sup> output reduction incorporates the <em>i</em><sup>th</sup> input. The term <em>exclusive</em> indicates the <em>i</em><sup>th</sup> input is not incorporated into the <em>i</em><sup>th</sup> output reduction.</dd></dl>
<dl class="section user"><dt></dt><dd>For convenience, <a class="el" href="classcub_1_1_warp_scan.html" title="WarpScan provides variants of parallel prefix scan across CUDA warps. . ">WarpScan</a> provides alternative entrypoints that differ by:<ul>
<li>Operator (generic scan <b><em>vs.</em></b> prefix sum of numeric types)</li>
<li>Output ordering (inclusive <b><em>vs.</em></b> exclusive)</li>
<li>Warp-wide prefix (identity <b><em>vs.</em></b> call-back functor)</li>
<li>What is computed (scanned elements only <b><em>vs.</em></b> scanned elements and the total aggregate)</li>
</ul>
</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scan input/output element type </td></tr>
    <tr><td class="paramname">LOGICAL_WARPS</td><td><b>[optional]</b> The number of "logical" warps performing concurrent warp scans. Default is 1. </td></tr>
    <tr><td class="paramname">LOGICAL_WARP_THREADS</td><td><b>[optional]</b> The number of threads per "logical" warp (may be less than the number of hardware warp threads). Default is the warp size associated with the CUDA Compute Capability targeted by the compiler (e.g., 32 threads for SM20).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Usage Considerations</dt><dd><ul>
<li>Supports non-commutative scan operators</li>
<li>Supports "logical" warps smaller than the physical warp size (e.g., a logical warp of 8 threads)</li>
<li>Warp scans are concurrent if more than one warp is participating</li>
<li>After any operation, a subsequent <code>__syncthreads()</code> barrier is required if the collective's <a class="el" href="classcub_1_1_warp_scan.html#a7e6bd578fe8c88ba7e4506d3e8b1c695" title="The operations exposed by WarpScan require a temporary memory allocation of this type for thread comm...">WarpScan::TempStorage</a> is to be reused or repurposed</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Performance Considerations</dt><dd><ul>
<li>Uses special instructions when applicable (e.g., warp <code>SHFL</code>)</li>
<li>Uses synchronization-free communication between warp lanes when applicable</li>
<li>Zero bank conflicts for most types.</li>
<li>Computation is slightly more efficient (i.e., having lower instruction overhead) for:<ul>
<li>Prefix sum variants (vs. generic scan)</li>
<li>Exclusive variants (vs. inclusive)</li>
<li>Basic scan variants that don't require scalar inputs and outputs (e.g., <code>warp_prefix_op</code> and <code>warp_aggregate</code>)</li>
<li>Scan parameterizations where <code>T</code> is a built-in C++ primitive or CUDA vector type (e.g., <code>short</code>, <code>int2</code>, <code>double</code>, <code>float2</code>, etc.)</li>
<li>Scan parameterizations where <code>LOGICAL_WARP_THREADS</code> is a multiple of the architecture's warp size</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Algorithm</dt><dd>These parallel prefix scan variants implement a warp-synchronous Kogge-Stone algorithm having <em>O</em>(log<em>n</em>) steps and <em>O</em>(<em>n</em>log<em>n</em>) work complexity, where <em>n</em> = <code>LOGICAL_WARP_THREADS</code> (which defaults to the warp size associated with the CUDA Compute Capability targeted by the compiler). <br/>
<br/>
 <div class="image">
<img src="kogge_stone_scan.png" alt="kogge_stone_scan.png"/>
</div>
 <div class="centercaption">Data flow within a 16-thread Kogge-Stone scan construction. Junctions represent binary operators.</div> <br/>
</dd></dl>
<dl class="section user"><dt>Examples</dt><dd><em>Example 1.</em> Perform a simple exclusive prefix sum for one warp <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"></div>
<div class="line">__global__ <span class="keywordtype">void</span> SomeKernel(...)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Parameterize WarpScan for 1 warp on type int</span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classcub_1_1_warp_scan.html" title="WarpScan provides variants of parallel prefix scan across CUDA warps. . ">cub::WarpScan&lt;int&gt;</a> <a class="code" href="classcub_1_1_warp_scan.html#a27ca414b95f92f2b52701cda45273b05" title="Collective constructor for 1D thread blocks using a private static allocation of shared memory as tem...">WarpScan</a>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Opaque shared memory for WarpScan</span></div>
<div class="line">    __shared__ <span class="keyword">typename</span> <a class="code" href="classcub_1_1_warp_scan.html#a7e6bd578fe8c88ba7e4506d3e8b1c695" title="The operations exposed by WarpScan require a temporary memory allocation of this type for thread comm...">WarpScan::TempStorage</a> temp_storage;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Perform prefix sum of threadIds in first warp</span></div>
<div class="line">    <span class="keywordflow">if</span> (linear_tid &lt; 32)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">int</span> input = linear_tid;</div>
<div class="line">        <span class="keywordtype">int</span> output;</div>
<div class="line">        WarpScan::ExclusiveSum(temp_storage, input, output);</div>
<div class="line"></div>
<div class="line">        printf(<span class="stringliteral">&quot;tid(%d) output(%d)\n\n&quot;</span>, linear_tid, output);</div>
<div class="line">    }</div>
</div><!-- fragment --> Printed output: <div class="fragment"><div class="line">tid(0) output(0)</div>
<div class="line">tid(1) output(0)</div>
<div class="line">tid(2) output(1)</div>
<div class="line">tid(3) output(3)</div>
<div class="line">tid(4) output(6)</div>
<div class="line">...</div>
<div class="line">tid(31) output(465)</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd><em>Example 2.</em> Use a single warp to iteratively compute an exclusive prefix sum over a larger input using a prefix functor to maintain a running total between scans. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Stateful functor that maintains a running prefix that can be applied to</span></div>
<div class="line"><span class="comment">// consecutive scan operations.</span></div>
<div class="line"><span class="keyword">struct </span>WarpPrefixOp</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Running prefix</span></div>
<div class="line">    <span class="keywordtype">int</span> running_total;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Constructor</span></div>
<div class="line">    __device__ WarpPrefixOp(<span class="keywordtype">int</span> running_total) : running_total(running_total) {}</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Callback operator, called by the entire warp of threads.</span></div>
<div class="line">    <span class="comment">// Lane-0 produces a value for seeding the warp-wide scan given</span></div>
<div class="line">    <span class="comment">// the local aggregate.</span></div>
<div class="line">    __device__ <span class="keywordtype">int</span> operator()(<span class="keywordtype">int</span> warp_aggregate)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">int</span> old_prefix = running_total;</div>
<div class="line">        running_total += warp_aggregate;</div>
<div class="line">        <span class="keywordflow">return</span> old_prefix;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">__global__ <span class="keywordtype">void</span> SomeKernel(<span class="keywordtype">int</span> *d_data, <span class="keywordtype">int</span> num_elements)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Parameterize WarpScan for 1 warp on type int</span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classcub_1_1_warp_scan.html" title="WarpScan provides variants of parallel prefix scan across CUDA warps. . ">cub::WarpScan&lt;int&gt;</a> <a class="code" href="classcub_1_1_warp_scan.html#a27ca414b95f92f2b52701cda45273b05" title="Collective constructor for 1D thread blocks using a private static allocation of shared memory as tem...">WarpScan</a>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Opaque shared memory for WarpScan</span></div>
<div class="line">    __shared__ <span class="keyword">typename</span> <a class="code" href="classcub_1_1_warp_scan.html#a7e6bd578fe8c88ba7e4506d3e8b1c695" title="The operations exposed by WarpScan require a temporary memory allocation of this type for thread comm...">WarpScan::TempStorage</a> temp_storage;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The first warp iteratively computes a prefix sum over d_data</span></div>
<div class="line">    <span class="keywordflow">if</span> (linear_tid &lt; 32)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Running total</span></div>
<div class="line">        WarpPrefixOp prefix_op(0);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Iterate in strips of 32 items</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> warp_offset = 0; warp_offset &lt; num_elements; warp_offset += 32)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Read item</span></div>
<div class="line">            <span class="keywordtype">int</span> datum = d_data[warp_offset + linear_tid];</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Scan the tile of items</span></div>
<div class="line">            <span class="keywordtype">int</span> tile_aggregate;</div>
<div class="line">            WarpScan::ExclusiveSum(temp_storage, datum, datum,</div>
<div class="line">                tile_aggregate, prefix_op);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Write item</span></div>
<div class="line">            d_data[warp_offset + linear_tid] = datum;</div>
<div class="line">        }</div>
<div class="line">    }</div>
</div><!-- fragment --> </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7e6bd578fe8c88ba7e4506d3e8b1c695"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e6bd578fe8c88ba7e4506d3e8b1c695"></a>
typedef _TempStorage&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#a7e6bd578fe8c88ba7e4506d3e8b1c695">TempStorage</a></td></tr>
<tr class="memdesc:a7e6bd578fe8c88ba7e4506d3e8b1c695"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operations exposed by <a class="el" href="classcub_1_1_warp_scan.html" title="WarpScan provides variants of parallel prefix scan across CUDA warps. . ">WarpScan</a> require a temporary memory allocation of this type for thread communication. This opaque storage can be allocated directly using the <code>__shared__</code> keyword. Alternatively, it can be aliased to externally allocated memory (shared or global) or <code>union</code>'d with other storage allocation types to facilitate memory reuse. <br/></td></tr>
<tr class="separator:a7e6bd578fe8c88ba7e4506d3e8b1c695"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Methods</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Collective construction</div></td></tr>
<tr class="memitem:a27ca414b95f92f2b52701cda45273b05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27ca414b95f92f2b52701cda45273b05"></a>
__device__ __forceinline__&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#a27ca414b95f92f2b52701cda45273b05">WarpScan</a> ()</td></tr>
<tr class="memdesc:a27ca414b95f92f2b52701cda45273b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collective constructor for 1D thread blocks using a private static allocation of shared memory as temporary storage. Logical warp and lane identifiers are constructed from <code>threadIdx.x</code>. <br/></td></tr>
<tr class="separator:a27ca414b95f92f2b52701cda45273b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037e31be8f0e394e2b7a6ce02f24042e"><td class="memItemLeft" align="right" valign="top">__device__ __forceinline__&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#a037e31be8f0e394e2b7a6ce02f24042e">WarpScan</a> (<a class="el" href="classcub_1_1_warp_scan.html#a7e6bd578fe8c88ba7e4506d3e8b1c695">TempStorage</a> &amp;temp_storage)</td></tr>
<tr class="memdesc:a037e31be8f0e394e2b7a6ce02f24042e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collective constructor for 1D thread blocks using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from <code>threadIdx.x</code>.  <a href="#a037e31be8f0e394e2b7a6ce02f24042e">More...</a><br/></td></tr>
<tr class="separator:a037e31be8f0e394e2b7a6ce02f24042e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e1da90057f72813e2ad36af598dcc2"><td class="memItemLeft" align="right" valign="top">__device__ __forceinline__&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#aa8e1da90057f72813e2ad36af598dcc2">WarpScan</a> (int warp_id, int lane_id)</td></tr>
<tr class="memdesc:aa8e1da90057f72813e2ad36af598dcc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collective constructor using a private static allocation of shared memory as temporary storage. Threads are identified using the given warp and lane identifiers.  <a href="#aa8e1da90057f72813e2ad36af598dcc2">More...</a><br/></td></tr>
<tr class="separator:aa8e1da90057f72813e2ad36af598dcc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9787551c8a6e2a23f9d32cd029151093"><td class="memItemLeft" align="right" valign="top">__device__ __forceinline__&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#a9787551c8a6e2a23f9d32cd029151093">WarpScan</a> (<a class="el" href="classcub_1_1_warp_scan.html#a7e6bd578fe8c88ba7e4506d3e8b1c695">TempStorage</a> &amp;temp_storage, int warp_id, int lane_id)</td></tr>
<tr class="memdesc:a9787551c8a6e2a23f9d32cd029151093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collective constructor using the specified memory allocation as temporary storage. Threads are identified using the given warp and lane identifiers.  <a href="#a9787551c8a6e2a23f9d32cd029151093">More...</a><br/></td></tr>
<tr class="separator:a9787551c8a6e2a23f9d32cd029151093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Inclusive prefix sums</div></td></tr>
<tr class="memitem:a64d246eb963f9a18d964e17a6f73fc27"><td class="memItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#a64d246eb963f9a18d964e17a6f73fc27">InclusiveSum</a> (T input, T &amp;output)</td></tr>
<tr class="memdesc:a64d246eb963f9a18d964e17a6f73fc27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an inclusive prefix sum in each logical warp.  <a href="#a64d246eb963f9a18d964e17a6f73fc27">More...</a><br/></td></tr>
<tr class="separator:a64d246eb963f9a18d964e17a6f73fc27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601da756b6729894ec8a52080d920cd4"><td class="memItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#a601da756b6729894ec8a52080d920cd4">InclusiveSum</a> (T input, T &amp;output, T &amp;warp_aggregate)</td></tr>
<tr class="memdesc:a601da756b6729894ec8a52080d920cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an inclusive prefix sum in each logical warp. Also provides every thread with the warp-wide <code>warp_aggregate</code> of all inputs.  <a href="#a601da756b6729894ec8a52080d920cd4">More...</a><br/></td></tr>
<tr class="separator:a601da756b6729894ec8a52080d920cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906d0d6381b3af1ad105ec69547350f3"><td class="memTemplParams" colspan="2">template&lt;typename WarpPrefixOp &gt; </td></tr>
<tr class="memitem:a906d0d6381b3af1ad105ec69547350f3"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#a906d0d6381b3af1ad105ec69547350f3">InclusiveSum</a> (T input, T &amp;output, T &amp;warp_aggregate, WarpPrefixOp &amp;warp_prefix_op)</td></tr>
<tr class="memdesc:a906d0d6381b3af1ad105ec69547350f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an inclusive prefix sum in each logical warp. Instead of using 0 as the warp-wide prefix, the call-back functor <code>warp_prefix_op</code> is invoked to provide the "seed" value that logically prefixes the warp's scan inputs. Also provides every thread with the warp-wide <code>warp_aggregate</code> of all inputs.  <a href="#a906d0d6381b3af1ad105ec69547350f3">More...</a><br/></td></tr>
<tr class="separator:a906d0d6381b3af1ad105ec69547350f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Exclusive prefix sums</div></td></tr>
<tr class="memitem:acf4960fcb08e5960ca7c9aa28a34ae1c"><td class="memItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#acf4960fcb08e5960ca7c9aa28a34ae1c">ExclusiveSum</a> (T input, T &amp;output)</td></tr>
<tr class="memdesc:acf4960fcb08e5960ca7c9aa28a34ae1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive prefix sum in each logical warp.  <a href="#acf4960fcb08e5960ca7c9aa28a34ae1c">More...</a><br/></td></tr>
<tr class="separator:acf4960fcb08e5960ca7c9aa28a34ae1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68084364e2235b53998861731b267f8"><td class="memItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#ab68084364e2235b53998861731b267f8">ExclusiveSum</a> (T input, T &amp;output, T &amp;warp_aggregate)</td></tr>
<tr class="memdesc:ab68084364e2235b53998861731b267f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive prefix sum in each logical warp. Also provides every thread with the warp-wide <code>warp_aggregate</code> of all inputs.  <a href="#ab68084364e2235b53998861731b267f8">More...</a><br/></td></tr>
<tr class="separator:ab68084364e2235b53998861731b267f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283236673ad2e54579f6b5ee97eac193"><td class="memTemplParams" colspan="2">template&lt;typename WarpPrefixOp &gt; </td></tr>
<tr class="memitem:a283236673ad2e54579f6b5ee97eac193"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#a283236673ad2e54579f6b5ee97eac193">ExclusiveSum</a> (T input, T &amp;output, T &amp;warp_aggregate, WarpPrefixOp &amp;warp_prefix_op)</td></tr>
<tr class="memdesc:a283236673ad2e54579f6b5ee97eac193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive prefix sum in each logical warp. Instead of using 0 as the warp-wide prefix, the call-back functor <code>warp_prefix_op</code> is invoked to provide the "seed" value that logically prefixes the warp's scan inputs. Also provides every thread with the warp-wide <code>warp_aggregate</code> of all inputs.  <a href="#a283236673ad2e54579f6b5ee97eac193">More...</a><br/></td></tr>
<tr class="separator:a283236673ad2e54579f6b5ee97eac193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Inclusive prefix scans</div></td></tr>
<tr class="memitem:aafd14f3920c493b104a3a6a0cc6a39d2"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp &gt; </td></tr>
<tr class="memitem:aafd14f3920c493b104a3a6a0cc6a39d2"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#aafd14f3920c493b104a3a6a0cc6a39d2">InclusiveScan</a> (T input, T &amp;output, ScanOp scan_op)</td></tr>
<tr class="memdesc:aafd14f3920c493b104a3a6a0cc6a39d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an inclusive prefix sum using the specified binary scan functor in each logical warp.  <a href="#aafd14f3920c493b104a3a6a0cc6a39d2">More...</a><br/></td></tr>
<tr class="separator:aafd14f3920c493b104a3a6a0cc6a39d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2ac5f642393ccfc698aa515e192a22"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp &gt; </td></tr>
<tr class="memitem:a6a2ac5f642393ccfc698aa515e192a22"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#a6a2ac5f642393ccfc698aa515e192a22">InclusiveScan</a> (T input, T &amp;output, ScanOp scan_op, T &amp;warp_aggregate)</td></tr>
<tr class="memdesc:a6a2ac5f642393ccfc698aa515e192a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an inclusive prefix sum using the specified binary scan functor in each logical warp. Also provides every thread with the warp-wide <code>warp_aggregate</code> of all inputs.  <a href="#a6a2ac5f642393ccfc698aa515e192a22">More...</a><br/></td></tr>
<tr class="separator:a6a2ac5f642393ccfc698aa515e192a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf74795dbe02947facd24657bc519c40"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp , typename WarpPrefixOp &gt; </td></tr>
<tr class="memitem:adf74795dbe02947facd24657bc519c40"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#adf74795dbe02947facd24657bc519c40">InclusiveScan</a> (T input, T &amp;output, ScanOp scan_op, T &amp;warp_aggregate, WarpPrefixOp &amp;warp_prefix_op)</td></tr>
<tr class="memdesc:adf74795dbe02947facd24657bc519c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an inclusive prefix sum using the specified binary scan functor in each logical warp. The call-back functor <code>warp_prefix_op</code> is invoked to provide the "seed" value that logically prefixes the warp's scan inputs. Also provides every thread with the warp-wide <code>warp_aggregate</code> of all inputs.  <a href="#adf74795dbe02947facd24657bc519c40">More...</a><br/></td></tr>
<tr class="separator:adf74795dbe02947facd24657bc519c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Exclusive prefix scans</div></td></tr>
<tr class="memitem:aafbc42fcea0a11b83289629554cbe625"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp &gt; </td></tr>
<tr class="memitem:aafbc42fcea0a11b83289629554cbe625"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#aafbc42fcea0a11b83289629554cbe625">ExclusiveScan</a> (T input, T &amp;output, T identity, ScanOp scan_op)</td></tr>
<tr class="memdesc:aafbc42fcea0a11b83289629554cbe625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive prefix scan using the specified binary scan functor in each logical warp.  <a href="#aafbc42fcea0a11b83289629554cbe625">More...</a><br/></td></tr>
<tr class="separator:aafbc42fcea0a11b83289629554cbe625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d36c6cf146b69c1cf91d4781b96374"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp &gt; </td></tr>
<tr class="memitem:a09d36c6cf146b69c1cf91d4781b96374"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#a09d36c6cf146b69c1cf91d4781b96374">ExclusiveScan</a> (T input, T &amp;output, T identity, ScanOp scan_op, T &amp;warp_aggregate)</td></tr>
<tr class="memdesc:a09d36c6cf146b69c1cf91d4781b96374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive prefix scan using the specified binary scan functor in each logical warp. Also provides every thread with the warp-wide <code>warp_aggregate</code> of all inputs.  <a href="#a09d36c6cf146b69c1cf91d4781b96374">More...</a><br/></td></tr>
<tr class="separator:a09d36c6cf146b69c1cf91d4781b96374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada12695322d9e1f5354fcae9d0910113"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp , typename WarpPrefixOp &gt; </td></tr>
<tr class="memitem:ada12695322d9e1f5354fcae9d0910113"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#ada12695322d9e1f5354fcae9d0910113">ExclusiveScan</a> (T input, T &amp;output, T identity, ScanOp scan_op, T &amp;warp_aggregate, WarpPrefixOp &amp;warp_prefix_op)</td></tr>
<tr class="memdesc:ada12695322d9e1f5354fcae9d0910113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive prefix scan using the specified binary scan functor in each logical warp. The call-back functor <code>warp_prefix_op</code> is invoked to provide the "seed" value that logically prefixes the warp's scan inputs. Also provides every thread with the warp-wide <code>warp_aggregate</code> of all inputs.  <a href="#ada12695322d9e1f5354fcae9d0910113">More...</a><br/></td></tr>
<tr class="separator:ada12695322d9e1f5354fcae9d0910113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Identityless exclusive prefix scans</div></td></tr>
<tr class="memitem:a1f4e88a801bdfdfde342f23fb2768ea8"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp &gt; </td></tr>
<tr class="memitem:a1f4e88a801bdfdfde342f23fb2768ea8"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#a1f4e88a801bdfdfde342f23fb2768ea8">ExclusiveScan</a> (T input, T &amp;output, ScanOp scan_op)</td></tr>
<tr class="memdesc:a1f4e88a801bdfdfde342f23fb2768ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive prefix scan using the specified binary scan functor in each logical warp. Because no identity value is supplied, the <code>output</code> computed for <em>warp-lane</em><sub>0</sub> is undefined.  <a href="#a1f4e88a801bdfdfde342f23fb2768ea8">More...</a><br/></td></tr>
<tr class="separator:a1f4e88a801bdfdfde342f23fb2768ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51aef1f68a2ca876f7515b6b3213d72"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp &gt; </td></tr>
<tr class="memitem:af51aef1f68a2ca876f7515b6b3213d72"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#af51aef1f68a2ca876f7515b6b3213d72">ExclusiveScan</a> (T input, T &amp;output, ScanOp scan_op, T &amp;warp_aggregate)</td></tr>
<tr class="memdesc:af51aef1f68a2ca876f7515b6b3213d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive prefix scan using the specified binary scan functor in each logical warp. Because no identity value is supplied, the <code>output</code> computed for <em>warp-lane</em><sub>0</sub> is undefined. Also provides every thread with the warp-wide <code>warp_aggregate</code> of all inputs.  <a href="#af51aef1f68a2ca876f7515b6b3213d72">More...</a><br/></td></tr>
<tr class="separator:af51aef1f68a2ca876f7515b6b3213d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024d74c48e45b489843053097b0638d1"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp , typename WarpPrefixOp &gt; </td></tr>
<tr class="memitem:a024d74c48e45b489843053097b0638d1"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#a024d74c48e45b489843053097b0638d1">ExclusiveScan</a> (T input, T &amp;output, ScanOp scan_op, T &amp;warp_aggregate, WarpPrefixOp &amp;warp_prefix_op)</td></tr>
<tr class="memdesc:a024d74c48e45b489843053097b0638d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive prefix scan using the specified binary scan functor in each logical warp. The <code>warp_prefix_op</code> value from thread-thread-lane<sub>0</sub> is applied to all scan outputs. Also computes the warp-wide <code>warp_aggregate</code> of all inputs for thread-thread-lane<sub>0</sub>.  <a href="#a024d74c48e45b489843053097b0638d1">More...</a><br/></td></tr>
<tr class="separator:a024d74c48e45b489843053097b0638d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a037e31be8f0e394e2b7a6ce02f24042e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int LOGICAL_WARPS = 1, int LOGICAL_WARP_THREADS = PtxArchProps::WARP_THREADS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, LOGICAL_WARPS, LOGICAL_WARP_THREADS &gt;::<a class="el" href="classcub_1_1_warp_scan.html">WarpScan</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_warp_scan.html#a7e6bd578fe8c88ba7e4506d3e8b1c695">TempStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>temp_storage</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collective constructor for 1D thread blocks using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from <code>threadIdx.x</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">temp_storage</td><td>Reference to memory allocation having layout type TempStorage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa8e1da90057f72813e2ad36af598dcc2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int LOGICAL_WARPS = 1, int LOGICAL_WARP_THREADS = PtxArchProps::WARP_THREADS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, LOGICAL_WARPS, LOGICAL_WARP_THREADS &gt;::<a class="el" href="classcub_1_1_warp_scan.html">WarpScan</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>warp_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lane_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collective constructor using a private static allocation of shared memory as temporary storage. Threads are identified using the given warp and lane identifiers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">warp_id</td><td>A suitable warp membership identifier </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lane_id</td><td>A lane identifier within the warp </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9787551c8a6e2a23f9d32cd029151093"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int LOGICAL_WARPS = 1, int LOGICAL_WARP_THREADS = PtxArchProps::WARP_THREADS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, LOGICAL_WARPS, LOGICAL_WARP_THREADS &gt;::<a class="el" href="classcub_1_1_warp_scan.html">WarpScan</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_warp_scan.html#a7e6bd578fe8c88ba7e4506d3e8b1c695">TempStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>warp_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lane_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collective constructor using the specified memory allocation as temporary storage. Threads are identified using the given warp and lane identifiers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">temp_storage</td><td>Reference to memory allocation having layout type TempStorage </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">warp_id</td><td>A suitable warp membership identifier </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lane_id</td><td>A lane identifier within the warp </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a64d246eb963f9a18d964e17a6f73fc27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int LOGICAL_WARPS = 1, int LOGICAL_WARP_THREADS = PtxArchProps::WARP_THREADS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, LOGICAL_WARPS, LOGICAL_WARP_THREADS &gt;::InclusiveSum </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an inclusive prefix sum in each logical warp. </p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a601da756b6729894ec8a52080d920cd4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int LOGICAL_WARPS = 1, int LOGICAL_WARP_THREADS = PtxArchProps::WARP_THREADS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, LOGICAL_WARPS, LOGICAL_WARP_THREADS &gt;::InclusiveSum </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>warp_aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an inclusive prefix sum in each logical warp. Also provides every thread with the warp-wide <code>warp_aggregate</code> of all inputs. </p>
<p>The <code>warp_aggregate</code> is undefined in threads other than <em>warp-lane</em><sub>0</sub>.</p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">warp_aggregate</td><td>Warp-wide aggregate reduction of input items. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a906d0d6381b3af1ad105ec69547350f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int LOGICAL_WARPS = 1, int LOGICAL_WARP_THREADS = PtxArchProps::WARP_THREADS&gt; </div>
<div class="memtemplate">
template&lt;typename WarpPrefixOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, LOGICAL_WARPS, LOGICAL_WARP_THREADS &gt;::InclusiveSum </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>warp_aggregate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WarpPrefixOp &amp;&#160;</td>
          <td class="paramname"><em>warp_prefix_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an inclusive prefix sum in each logical warp. Instead of using 0 as the warp-wide prefix, the call-back functor <code>warp_prefix_op</code> is invoked to provide the "seed" value that logically prefixes the warp's scan inputs. Also provides every thread with the warp-wide <code>warp_aggregate</code> of all inputs. </p>
<p>The <code>warp_aggregate</code> is undefined in threads other than <em>warp-lane</em><sub>0</sub>.</p>
<p>The <code>warp_prefix_op</code> functor must implement a member function <code>T operator()(T warp_aggregate)</code>. The functor's input parameter <code>warp_aggregate</code> is the same value also returned by the scan operation. The functor will be invoked by the entire warp of threads, however only the return value from <em>lane</em><sub>0</sub> is applied as the threadblock-wide prefix. Can be stateful.</p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">WarpPrefixOp</td><td><b>[inferred]</b> Call-back functor type having member <code>T operator()(T warp_aggregate)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">warp_aggregate</td><td><b>[<em>warp-lane</em><sub>0</sub> only]</b> Warp-wide aggregate reduction of input items, exclusive of the <code>warp_prefix_op</code> value </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">warp_prefix_op</td><td><b>[<em>warp-lane</em><sub>0</sub> only]</b> Call-back functor for specifying a warp-wide prefix to be applied to all inputs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf4960fcb08e5960ca7c9aa28a34ae1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int LOGICAL_WARPS = 1, int LOGICAL_WARP_THREADS = PtxArchProps::WARP_THREADS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, LOGICAL_WARPS, LOGICAL_WARP_THREADS &gt;::ExclusiveSum </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive prefix sum in each logical warp. </p>
<p>This operation assumes the value of obtained by the <code>T</code>'s default constructor (or by zero-initialization if no user-defined default constructor exists) is suitable as the identity value "zero" for addition.</p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab68084364e2235b53998861731b267f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int LOGICAL_WARPS = 1, int LOGICAL_WARP_THREADS = PtxArchProps::WARP_THREADS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, LOGICAL_WARPS, LOGICAL_WARP_THREADS &gt;::ExclusiveSum </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>warp_aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive prefix sum in each logical warp. Also provides every thread with the warp-wide <code>warp_aggregate</code> of all inputs. </p>
<p>This operation assumes the value of obtained by the <code>T</code>'s default constructor (or by zero-initialization if no user-defined default constructor exists) is suitable as the identity value "zero" for addition.</p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">warp_aggregate</td><td>Warp-wide aggregate reduction of input items. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a283236673ad2e54579f6b5ee97eac193"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int LOGICAL_WARPS = 1, int LOGICAL_WARP_THREADS = PtxArchProps::WARP_THREADS&gt; </div>
<div class="memtemplate">
template&lt;typename WarpPrefixOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, LOGICAL_WARPS, LOGICAL_WARP_THREADS &gt;::ExclusiveSum </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>warp_aggregate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WarpPrefixOp &amp;&#160;</td>
          <td class="paramname"><em>warp_prefix_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive prefix sum in each logical warp. Instead of using 0 as the warp-wide prefix, the call-back functor <code>warp_prefix_op</code> is invoked to provide the "seed" value that logically prefixes the warp's scan inputs. Also provides every thread with the warp-wide <code>warp_aggregate</code> of all inputs. </p>
<p>This operation assumes the value of obtained by the <code>T</code>'s default constructor (or by zero-initialization if no user-defined default constructor exists) is suitable as the identity value "zero" for addition.</p>
<p>The <code>warp_prefix_op</code> functor must implement a member function <code>T operator()(T warp_aggregate)</code>. The functor's input parameter <code>warp_aggregate</code> is the same value also returned by the scan operation. The functor will be invoked by the entire warp of threads, however only the return value from <em>lane</em><sub>0</sub> is applied as the threadblock-wide prefix. Can be stateful.</p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">WarpPrefixOp</td><td><b>[inferred]</b> Call-back functor type having member <code>T operator()(T warp_aggregate)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">warp_aggregate</td><td><b>[<em>warp-lane</em><sub>0</sub> only]</b> Warp-wide aggregate reduction of input items (exclusive of the <code>warp_prefix_op</code> value). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">warp_prefix_op</td><td><b>[<em>warp-lane</em><sub>0</sub> only]</b> Call-back functor for specifying a warp-wide prefix to be applied to all inputs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aafd14f3920c493b104a3a6a0cc6a39d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int LOGICAL_WARPS = 1, int LOGICAL_WARP_THREADS = PtxArchProps::WARP_THREADS&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, LOGICAL_WARPS, LOGICAL_WARP_THREADS &gt;::InclusiveScan </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an inclusive prefix sum using the specified binary scan functor in each logical warp. </p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6a2ac5f642393ccfc698aa515e192a22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int LOGICAL_WARPS = 1, int LOGICAL_WARP_THREADS = PtxArchProps::WARP_THREADS&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, LOGICAL_WARPS, LOGICAL_WARP_THREADS &gt;::InclusiveScan </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>warp_aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an inclusive prefix sum using the specified binary scan functor in each logical warp. Also provides every thread with the warp-wide <code>warp_aggregate</code> of all inputs. </p>
<p>The <code>warp_aggregate</code> is undefined in threads other than <em>warp-lane</em><sub>0</sub>.</p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">warp_aggregate</td><td>Warp-wide aggregate reduction of input items. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf74795dbe02947facd24657bc519c40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int LOGICAL_WARPS = 1, int LOGICAL_WARP_THREADS = PtxArchProps::WARP_THREADS&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp , typename WarpPrefixOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, LOGICAL_WARPS, LOGICAL_WARP_THREADS &gt;::InclusiveScan </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>warp_aggregate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WarpPrefixOp &amp;&#160;</td>
          <td class="paramname"><em>warp_prefix_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an inclusive prefix sum using the specified binary scan functor in each logical warp. The call-back functor <code>warp_prefix_op</code> is invoked to provide the "seed" value that logically prefixes the warp's scan inputs. Also provides every thread with the warp-wide <code>warp_aggregate</code> of all inputs. </p>
<p>The <code>warp_aggregate</code> is undefined in threads other than <em>warp-lane</em><sub>0</sub>.</p>
<p>The <code>warp_prefix_op</code> functor must implement a member function <code>T operator()(T warp_aggregate)</code>. The functor's input parameter <code>warp_aggregate</code> is the same value also returned by the scan operation. The functor will be invoked by the entire warp of threads, however only the return value from <em>lane</em><sub>0</sub> is applied as the threadblock-wide prefix. Can be stateful.</p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
    <tr><td class="paramname">WarpPrefixOp</td><td><b>[inferred]</b> Call-back functor type having member <code>T operator()(T warp_aggregate)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">warp_aggregate</td><td><b>[<em>warp-lane</em><sub>0</sub> only]</b> Warp-wide aggregate reduction of input items (exclusive of the <code>warp_prefix_op</code> value). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">warp_prefix_op</td><td><b>[<em>warp-lane</em><sub>0</sub> only]</b> Call-back functor for specifying a warp-wide prefix to be applied to all inputs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aafbc42fcea0a11b83289629554cbe625"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int LOGICAL_WARPS = 1, int LOGICAL_WARP_THREADS = PtxArchProps::WARP_THREADS&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, LOGICAL_WARPS, LOGICAL_WARP_THREADS &gt;::ExclusiveScan </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive prefix scan using the specified binary scan functor in each logical warp. </p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">identity</td><td>Identity value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a09d36c6cf146b69c1cf91d4781b96374"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int LOGICAL_WARPS = 1, int LOGICAL_WARP_THREADS = PtxArchProps::WARP_THREADS&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, LOGICAL_WARPS, LOGICAL_WARP_THREADS &gt;::ExclusiveScan </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>warp_aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive prefix scan using the specified binary scan functor in each logical warp. Also provides every thread with the warp-wide <code>warp_aggregate</code> of all inputs. </p>
<p>The <code>warp_aggregate</code> is undefined in threads other than <em>warp-lane</em><sub>0</sub>.</p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">identity</td><td>Identity value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">warp_aggregate</td><td>Warp-wide aggregate reduction of input items. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ada12695322d9e1f5354fcae9d0910113"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int LOGICAL_WARPS = 1, int LOGICAL_WARP_THREADS = PtxArchProps::WARP_THREADS&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp , typename WarpPrefixOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, LOGICAL_WARPS, LOGICAL_WARP_THREADS &gt;::ExclusiveScan </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>warp_aggregate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WarpPrefixOp &amp;&#160;</td>
          <td class="paramname"><em>warp_prefix_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive prefix scan using the specified binary scan functor in each logical warp. The call-back functor <code>warp_prefix_op</code> is invoked to provide the "seed" value that logically prefixes the warp's scan inputs. Also provides every thread with the warp-wide <code>warp_aggregate</code> of all inputs. </p>
<p>The <code>warp_aggregate</code> is undefined in threads other than <em>warp-lane</em><sub>0</sub>.</p>
<p>The <code>warp_prefix_op</code> functor must implement a member function <code>T operator()(T warp_aggregate)</code>. The functor's input parameter <code>warp_aggregate</code> is the same value also returned by the scan operation. The functor will be invoked by the entire warp of threads, however only the return value from <em>lane</em><sub>0</sub> is applied as the threadblock-wide prefix. Can be stateful.</p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
    <tr><td class="paramname">WarpPrefixOp</td><td><b>[inferred]</b> Call-back functor type having member <code>T operator()(T warp_aggregate)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">identity</td><td>Identity value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">warp_aggregate</td><td><b>[<em>warp-lane</em><sub>0</sub> only]</b> Warp-wide aggregate reduction of input items (exclusive of the <code>warp_prefix_op</code> value). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">warp_prefix_op</td><td><b>[<em>warp-lane</em><sub>0</sub> only]</b> Call-back functor for specifying a warp-wide prefix to be applied to all inputs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1f4e88a801bdfdfde342f23fb2768ea8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int LOGICAL_WARPS = 1, int LOGICAL_WARP_THREADS = PtxArchProps::WARP_THREADS&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, LOGICAL_WARPS, LOGICAL_WARP_THREADS &gt;::ExclusiveScan </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive prefix scan using the specified binary scan functor in each logical warp. Because no identity value is supplied, the <code>output</code> computed for <em>warp-lane</em><sub>0</sub> is undefined. </p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af51aef1f68a2ca876f7515b6b3213d72"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int LOGICAL_WARPS = 1, int LOGICAL_WARP_THREADS = PtxArchProps::WARP_THREADS&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, LOGICAL_WARPS, LOGICAL_WARP_THREADS &gt;::ExclusiveScan </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>warp_aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive prefix scan using the specified binary scan functor in each logical warp. Because no identity value is supplied, the <code>output</code> computed for <em>warp-lane</em><sub>0</sub> is undefined. Also provides every thread with the warp-wide <code>warp_aggregate</code> of all inputs. </p>
<p>The <code>warp_aggregate</code> is undefined in threads other than <em>warp-lane</em><sub>0</sub>.</p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">warp_aggregate</td><td>Warp-wide aggregate reduction of input items. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a024d74c48e45b489843053097b0638d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int LOGICAL_WARPS = 1, int LOGICAL_WARP_THREADS = PtxArchProps::WARP_THREADS&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp , typename WarpPrefixOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, LOGICAL_WARPS, LOGICAL_WARP_THREADS &gt;::ExclusiveScan </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>warp_aggregate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WarpPrefixOp &amp;&#160;</td>
          <td class="paramname"><em>warp_prefix_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive prefix scan using the specified binary scan functor in each logical warp. The <code>warp_prefix_op</code> value from thread-thread-lane<sub>0</sub> is applied to all scan outputs. Also computes the warp-wide <code>warp_aggregate</code> of all inputs for thread-thread-lane<sub>0</sub>. </p>
<p>The <code>warp_aggregate</code> is undefined in threads other than <em>warp-lane</em><sub>0</sub>.</p>
<p>The <code>warp_prefix_op</code> functor must implement a member function <code>T operator()(T warp_aggregate)</code>. The functor's input parameter <code>warp_aggregate</code> is the same value also returned by the scan operation. The functor will be invoked by the entire warp of threads, however only the return value from <em>lane</em><sub>0</sub> is applied as the threadblock-wide prefix. Can be stateful.</p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
    <tr><td class="paramname">WarpPrefixOp</td><td><b>[inferred]</b> Call-back functor type having member <code>T operator()(T warp_aggregate)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">warp_aggregate</td><td><b>[<em>warp-lane</em><sub>0</sub> only]</b> Warp-wide aggregate reduction of input items (exclusive of the <code>warp_prefix_op</code> value). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">warp_prefix_op</td><td><b>[<em>warp-lane</em><sub>0</sub> only]</b> Call-back functor for specifying a warp-wide prefix to be applied to all inputs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="warp__scan_8cuh.html">warp_scan.cuh</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jul 27 2013 00:06:22 for CUB by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
<br>
&copy; 2013 NVIDIA Corporation
</small></address>
</body>
</html>
